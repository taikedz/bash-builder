#!/bin/bash

### Bash Builder 4 Usage:help
#
# Fourth version of the Bash Builder suite of tools.
#
# See https://github.com/taikedz/bash-builder
#
#
# Build a script using Bash Builder
#
# 	bbuild4 [OPTIONS ...] SCRIPTS ...
#
# Options
# -------
#
#   -c
#   --check
#   	use shellcheck for subsequent files
#
#   -C
#   --no-check
#   	don't use shellcheck for subsequent files
#
#   --ignore-tags
#   	Ignore tags in sourced files
#
#   --out=DIRECTORY
#   	Specify the output directory
#
# Environment
# -----------
#
# You can set environment variables in your .bashrc file, or in a local `./bbuild_env` file, which is sourced once before commencing build.
#
# The order of precedence for options and environment variables is:
#
# * command line arguments
# * `bbuild_env` settings
# * local environment settings
# * `.bashrc` settings
#
# Environment variables available, and their defaults:
#
# BBPATH -- a colon-separated list of directories wherein to find files for inclusion:
#
# 	BBPATH=$HOME/.local/lib/bbuild:/usr/local/lib/bbuild
#
#
# SHELLCHECK -- "true" or "false", whether to run shellcheck on the finally built script
#
# 	SHELLCHECK=false
#
#
# BUILDOUTD -- directory in which to place build results
#
#	BUILDOUTD=./build-outd
#
#
# IGNORETAGS -- if set to "unsafe", ignores tags and their effects.
#
# 	(unset by default)
#
# BBFILES -- a list of files to build ; overridden by any files specified on the command line
#   Surround these in parentheses to specify several scripts.
#   This allows simply running "bbuild" to build specified project scripts
#
# 	BBFILES=(src/script1 src/script2 libs/support_script)
#
###/doc

### notest FUNCTION ARGUMENTS Usage:bbuild
#
# This function performs a simple test to see if the "BBSETTESTMODE" variable is set to the string "test mode"
#
# If so, it does NOT call the function. In all other cases, the function is called with the arguments.
#
# The purpose of this function is to allow a simple method to encourage testability: source notest.sh in your test script, and set the BBTESTMODE variable to "test mode" to prevent the script from running.
#
# Example test target script, "test_target.sh":
#
#	#%include notest.sh
#
# 	function action1 { ... }
#
# 	function action2 { ... }
#
# 	function main {
# 		action1
# 		action2
# 	}
#
# 	notest main "$@"
#
# Example test script:
#
# 	. ~/.local/lib/bbuild/notest.sh
# 	BBTESTMODE="test mode"
#
# 	# main will not run
# 	. test_target.sh
#
# 	action1 || echo failed action1
#
# 	action2 || echo failed action2
#
# You can source a file with this kind of structure without the risk of triggering its runtime. This allows the file to be sourced and tested safely.
#
###/doc

function notest {
	local funcall="$1"; shift

	if [[ "${BBTESTMODE:-}" != "test mode" ]]; then
		"$funcall" "$@"
	fi
}
### Helper for version management Usage:bbuild
# Requires a version.bbuild in the current directory to work
###/doc

#%VERSIONFILE
BBVERSION_MAJOR=4
BBVERSION_MINOR=0
BBVERSION_POINT=2
BBVERSION_FLAG=dev
BBVERSION_PROGRAM=bbuild
BBVERSION_BUILDDATE=2017-05-29
BBVERSION_BUILD=68

function bbns_version_infoe {
	type infoe 2>&1|if grep 'not found' -q; then
		echo "$*"
	else
		infoe "$*"
	fi
}

function bbns_version_showversion {
	bbns_version_infoe "$BBVERSION_PROGRAM : $(bbns_version_genversion)"
	exit
}

function bbns_version_genversion {
	echo "$BBVERSION_MAJOR.$BBVERSION_MINOR.$BBVERSION_POINT ($BBVERSION_FLAG build $BBVERSION_BUILD) $BBVERSION_BUILDDATE"
}

if [[ "$*" =~ --version ]]; then
	bbns_version_showversion
fi

#!/bin/bash

### printhelp Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from a running script, call the
# `printhelp` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
###/doc

CHAR='#'

function printhelp {
	local USAGESTRING=help
	local TARGETFILE=$0
	if [[ -n "$*" ]]; then USAGESTRING="$1" ; shift; fi
	if [[ -n "$*" ]]; then TARGETFILE="$1" ; shift; fi

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$CHAR$CHAR$CHAR"'\s+(.+?)\s+Usage:'"$USAGESTRING"'\s*$'
        local SECEND='^\s*'"$CHAR$CHAR$CHAR"'\s*/doc\s*$'
        local insec="$(mktemp --tmpdir)"; rm "$insec"
        cat "$TARGETFILE" | while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        touch "$insec"
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"
                elif [[ -f $insec ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                rm "$insec"
                        else
				echo "$secline" | sed -r "s/^\s*$CHAR//g"
                        fi
                fi
        done
        if [[ -f "$insec" ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
		rm "$insec"
        fi
	echo ""
}

### automatic help Usage:main
#
# automatically call help if "--help" is detected in arguments
#
###/doc
if [[ "$@" =~ --help ]]; then
	cols="$(tput cols)"
	printhelp | fold -w "$cols" -s
	exit 0
fi
#!/bin/bash

### doinclusions Usage:bbuild
#
# Utility to allow developer-defined inclusion directives in files being processed.
#
###/doc

#!/bin/bash

### Find a file given a path list Usage:bbuild
#
# Usage:
#
# 	filefrom PATHDEF FILES ...
#
# Locate a file along a search path. The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
# 	filefrom "./lib:$HOME/.local/lib:/usr/local/lib" file1 file2 file3
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function filefrom {
	local PATHS="$1"; shift
	local FILE="$1"; shift

	debuge "file [$FILE] from [$PATHS]"

	for path in $(echo "$PATHS"|tr ':' ' '); do
		debuge "Try path: $path"
		local fpath="$path/$FILE"
		if [[ -f "$fpath" ]]; then
			echo "$fpath"
			return
		else
			debuge "No $fpath"
		fi
	done
	return 1
}
#!/bin/bash

### abspath Usage:bbuild
# Returns the absolute path of a file/directory
#
# Exposes two functions
#
#     abspath
#     abspath_collapse
#
# Do not use the python-based 'abspath' for intensitve resolution;
# instead, use native 'abspath_collapse' which is at least 170 times
# more efficient, at the cost of perhaps being potentially
# dumber (simply collapses '/./' and '/../').
# 
# Neither utility expands softlinks.
#
# If python is not found, abspath falls back to abspath_collapse systematically.
###/doc

function abspath {
	local newvar=${1//"'"/"\\'"}
	(
		set +eu
		if which python >/dev/null 2>&1; then
			python  -c "import os ; print os.path.abspath('$newvar')"
		elif which python3 >/dev/null 2>&1 ; then
			python3 -c "import os ; print(os.path.abspath('$newvar') )"
		else
			abspath_collapse "$newvar"
		fi
	)
}

# More efficient by a factor of at least 170:1
# compared to spinning up a python process every time
function abspath_collapse {
	local workpath="$1"
	if [[ "${workpath:0:1}" != "/" ]]; then workpath="$PWD/$workpath"; fi
	for x in {1..50}; do # set a limit on how many iterations - only very stupid paths will get us here.
		if [[ "$workpath" =~ '/../' ]] || [[ "$workpath" =~ '/./' ]]; then
			workpath="$(echo "$workpath"|sed -r -e 's#/./#/#g' -e 's#([^/]+)/../#\1/#g' -e 's#/.$##' -e 's#([^/]+)/..$#\1#' )"
		else
			echo "$workpath"
			return 0
		fi
	done
	return 1 # hopefully we never get here
}

### includefile_doincludes INFILE PATTERN [SEARCHPATHS] Usage:bbuild
#
# Inserts the contents of the files specified on lines matched by PATTERN into the stream of INFILE
# at the location they are declared.
#
# Inclusion directives must stand alone on their lines.
#
# Example:
#
# 	This is some content in the FILE called myfile.txt
#
# 	@@include external_file.txt external_2.txt
#
# 	We cannot include in the middle of a line. The following
# 	line will not be processed:
#
# 	( some line with @@inclusion file1 file2 )
#
# We can call this to include the contents of each file:
#
# 	doincludes myfile.txt '@@include'
#
# The result will be something like
#
# 	This is some content in the FILE called myfile.txt
#
# 	(file1 contents)
#
# 	(file2 contents)
#
# 	We cannot include in the middle of a line. The following
# 	line will not be processed:
#
# 	( some line with @@inclusion file1 file2 )
#
# Note that files for inclusion MUST NOT have spaces in their names, or in their paths.
#
# SEARCH PATHS
# ============
#
# You can specify a colon (":") -separated list of directories wherein to search for files by calling
#
# 	doincludes FILE PAT SEARCHPATHS
#
# This will search for the inclusions specified only along the specified paths. Example:
#
# 	doincludes myfile.html '//!addstyle' "./importedstyles:$HOME/.local/lib/styles:/etc/htmlthing/styles"
# 
# This will seek to include the files named in the inclusion line of myfile.html first from a local ./importedstyles,
#  then from a general home configuration, and finally if it has found the file in neither the previous, it will be
#  searched for in the global configuration.
#
# If not specified, the default search path is simply the containing directory of myfile.html.
#
###/doc

function includefile_doincludes {
	local INFILE="$1"; shift
	local PATTERN="$1"; shift
	local PATHS="$*"

	 while read inline; do
		debuge "[36;1mInclusion target: $inline[0m"
	 	local pos="${inline%%:*}"
		inline="${inline#*:}"

		local inclusiontargets="${inline#$PATTERN }"

		# reverse inclusion targets
		# to insert always at same line, but preserve order of declaration
		local revintar=
		for targetfile in $inclusiontargets ; do
			revintar="$targetfile $revintar"
		done

		for targetfile in $revintar; do
			if [[ -z "$targetfile" ]]; then continue; fi
			local filepath="$(filefrom "$PATHS" "$targetfile")"
			if [[ ! -f "$filepath" ]]; then
				warne "Could not find $targetfile in any of $PATHS"
				return 1
			fi
			fileinsert "$filepath" "$pos" "$INFILE"
		done

		sed "$pos d" -i "$INFILE"
	 done < <(grep -P "^$PATTERN" "$INFILE" -n | sort -r -n)
}

### fileinsert SOURCEFILE POSITION TARGETFILE Usage:bbuild
#
# Insert the contents of SOURCEFILE into TARGETFILE after line at POSITION
#
###/doc
function fileinsert {
	local SOURCEFILE="$(abspath $1)"; shift
	local POSITION="$1"; shift
	local TARGETFILE="$1"; shift

	local SKIPFILE="$(bbns_includes_getskipfile "$TARGETFILE")"

	if bbns_includes_registerfile "$SKIPFILE" "$SOURCEFILE"; then
		debuge "Inserting $SOURCEFILE at $TARGETFILE:$POSITION"

		bbns_includes_docallback "$SOURCEFILE" "$TARGETFILE"

		sed "$POSITION r $SOURCEFILE" -i "$TARGETFILE"
	fi
}

function bbns_includes_docallback {
	if [[ -n "$FILEINCLUDES_CALLBACK" ]]; then
		"$FILEINCLUDES_CALLBACK" "$@"
	fi
}

# Initialize the temp file
function includefile_inittemp {
	echo > "$(bbns_includes_getskipfile "$1")"
}

# Get skipfile for path
# getskipfile TARGETPATH
# prints a temp file path in /tmp
function bbns_includes_getskipfile {
	local tmpdir=/tmp/bbinclude
	mkdir -p "$tmpdir"
	
	local hash="$(echo "$1"|sha1sum)"
	hash="${hash:0:6}"

	local skipfile="$tmpdir/$hash"
	touch "$skipfile"
	echo "$skipfile"
}

# Internal method
# Register that a file has previously been included
# Returns 1 if already registered
function bbns_includes_registerfile {
	local SKIPFILE="$1"; shift
	local TARGETFILE="$1"; shift

	if bbns_includes_isregistered "$SKIPFILE" "$TARGETFILE"; then
		return 1
	fi

	echo "$TARGETFILE" >> "$SKIPFILE"
}

# Internal method
# check if file has already been reigstered
# returns 0 if yes
# returns 1 otherwise
function bbns_includes_isregistered {
	local SKIPFILE="$1"; shift
	local TARGETFILE="$1"; shift

	if grep -P -q "^$TARGETFILE$" "$SKIPFILE"; then
		return 0
	fi

	return 1
}
#!/bin/bash

#!/bin/bash

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour"
#
# Colours available:
#
# CDEF -- switches to the terminal default
#
# CRED, CBRED -- red and bright/bold red
# CGRN, CBGRN -- green and bright/bold green
# CYEL, CBYEL -- yellow and bright/bold yellow
# CBLU, CBBLU -- blue and bright/bold blue
# CPUR, CBPUR -- purple and bright/bold purple
#
###/doc

export CDEF="[0m"
export CRED="[31m"
export CGRN="[32m"
export CYEL="[33m"
export CBLU="[34m"
export CPUR="[35m"
export CBRED="[1;31m"
export CBGRN="[1;32m"
export CBYEL="[1;33m"
export CBBLU="[1;34m"
export CBPUR="[1;35m"

MODE_DEBUG=no

### debuge MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "yes"
###/doc
function debuge {
	if [[ "$MODE_DEBUG" = yes ]]; then
		echo -e "${CBBLU}DEBUG:$CBLU$*$CDEF" 1>&2
	fi
}

### infoe MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function infoe {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### warne MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function warne {
	echo -e "${CBYEL}WARN:$CYEL $*$CDEF" 1>&2
}

### faile [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function faile {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift
	fi

	echo "${CBRED}ERROR FAIL:$CRED$*$CDEF" 1>&2
	exit $ERCODE
}

function dumpe {
	echo -n "[1;35m$*" 1>&2
	echo -n "[0;35m" 1>&2
	cat - 1>&2
	echo -n "[0m" 1>&2
}

function breake {
	if [[ "$MODE_DEBUG" != yes ]]; then
		return
	fi

	read -p "${CRED}BREAKPOINT: $* >$CDEF " >&2
	if [[ "$REPLY" =~ $(echo 'quit|exit|stop') ]]; then
		faile "ABORT"
	fi
}

### Auto debug Usage:main
# When included, bashout processes a special "--debug" flag
#
# It does not remove the debug flag from arguments.
###/doc

if [[ "$*" =~ --debug ]]; then
	MODE_DEBUG=yes
fi
#!/bin/bash

### getbin COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	getbin markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

function getbin {
	local BINEXE=
	for binname in "$@"; do
		# Some implementations of `which` print error messages
		# Not useful here.
		BINEXE=$(which "$binname" 2>/dev/null)

		if [[ -n "$BINEXE" ]]; then
			echo "$BINEXE"
			return 0
		fi
	done
	return 1
}

### hasbin COMMANDS ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

function hasbin {
	[[ -n "$(getbin "$@")" ]]
}
bbuild_versiondir=./bbversiondata/

function bbuild_version_init {
	bbuild_versionfile="$bbuild_versiondir/$1"; shift

	if [[ ! -f "$bbuild_versionfile" ]]; then
	mkdir -p "$bbuild_versiondir"
cat <<EOF > "$bbuild_versionfile"
BBVERSION_MAJOR=0
BBVERSION_MINOR=0
BBVERSION_POINT=0
BBVERSION_FLAG=dev
EOF
	fi
}

function bbuild_version_bump {
	local part="$1"; shift

	local partval="$(bbuild_version_get "$part")"

	sed -r -e "s/^BBVERSION_${part}=.+/BBVERSION_${part}=$(( partval+1 ))/" -i "$bbuild_versionfile"
}

function bbuild_version_get {
	local part="$1"; shift

	egrep "^BBVERSION_${part}=" "$bbuild_versionfile" | cut -d'=' -f2
}

function bbuild_version_adddetails {
	debuge "Adding details from $bbuild_versionfile on $*"

	bbuild_version_detailfix "$bbuild_versionfile" PROGRAM "$1"

	if [[ "${BBVERSION_NOBUMP:-}" != true ]]; then
		bbuild_version_detailfix "$bbuild_versionfile" BUILDDATE "$(date +%F)"

		local buildnum="$(bbuild_version_get BUILD)"
		bbuild_version_detailfix "$bbuild_versionfile" BUILD "$((buildnum + 1))"
	fi
}

function bbuild_version_detailfix {
	local targetfile="$1"; shift
	local token="BBVERSION_$1"; shift
	local goalvalue="${token}=$*"

	debuge "Setting $token as $goalvalue"

	if grep "${token}=" "$targetfile" -q; then
		sed -r -e "s/^${token}=.*$/$goalvalue/" -i "$targetfile"

	elif [[ "${DFIX_NOADD:-}" != true ]]; then
		echo "$goalvalue" >> "$targetfile"

	fi
}

function bbuild_version_setrelease {
	# Set release on a built file
	local builtfile="$1"; shift

	DFIX_NOADD=true bbuild_version_detailfix "$builtfile" FLAG release
}
### Insert file contents Usage:bbuild
# 
# insert_file LINE DESTFILE SOURCEFILE
#
# Inserts the contents of SOURCEFILE into DESTFILE after line LINENUM
#
# When LINENUM is 0, inserts the contents before any of the lines of the file.
#
###/doc

function insert_file_sedappend {
	local line="$1"
	local destfile="$2"
	local sourcefile="$3"

	sed "$line r $sourcefile" -i "$destfile"
}

function insert_file_sedinsert {
	local destfile="$1"
	local sourcefile="$2"
	sed "1 {
		h
		r $sourcefile
		g
		N
	}" -i "$destfile"
}

function checkargs {
	if [[ ! "$1" =~ ^[0-9]+$ ]]; then echo "Invalid line number"; return 1 ; fi
	if [[ ! -f "$2" ]]; then echo "Not a file $2" >&2; return 1; fi
	if [[ ! -f "$3" ]]; then echo "Not a file $3" >&2; return 1; fi
}

function insert_file {
	checkargs "$@" || return 1

	if [[ "$1" = 0 ]]; then
		insert_file_sedinsert "$2" "$3"
	else
		insert_file_sedappend "$@"
	fi
}

function setup_build_dir {
	mkdir -p "$BUILDOUTD"
}

function load_project_environment {
	if [[ -f  "$BBUILD_ENV_FILE" ]]; then
		. "$BBUILD_ENV_FILE"
	fi
}

# checktags { FILENAME | TAG SPEC }
function checktags {
	if [[ -z "${1:-}" ]]; then return; fi

	if [[ "${IGNORETAGS:-}" = unsafe ]]; then
		return
	fi

	local tagsname="#%bbtags"
	if [[ "$1" != "$tagsname" ]]; then
		checktags $(grep "^$tagsname" "$1")
		return
	fi

	shift; # first arg is the bbtag
	
	for tag in "$@"; do
		case "$tag" in
			i:*)
				infoe "TAGS: $tag"
				;;
			w:*)
				warne "TAGS: $tag"
				;;
			e:*)
				faile "TAGS: $tag"
				;;
			*)	
				debuge "TAGS: $tag"
				;;
		esac
	done
}

function build_script {
	local infile="$1"; shift
	local t_BBPATH="$(dirname "$infile"):$BBPATH"

	local fname="$(basename "$infile")"
	local tfile="$BUILDOUTD/$fname"
	cp "$infile" "$tfile"

	infoe "Building $infile to $tfile"

	local intoken="#%include"

	includefile_inittemp "$tfile"

	while grep -P "^$intoken" -q "$tfile" ; do
		includefile_doincludes "$tfile" "$intoken" "$t_BBPATH" || faile "Inclusion on $tfile failed."
	done

	checktags "$tfile"

	postbuild_setrelease "$tfile"

	chmod 755 "$tfile"
}

function postbuild_setrelease {
	local targetfile="$1"; shift

	write_versioning_to "$targetfile"

	if [[ "${DOSETRELEASE:-}" = true ]]; then
		# will not append, so if versioning is not in use, file will not be affected
		DFIX_NOADD=true bbuild_version_detailfix "$targetfile" FLAG release
	fi
}

# Register callback function on-inclusion
FILEINCLUDES_CALLBACK=file_inclusion_callback
function file_inclusion_callback {
	debuge "calling back on $1 into $2"
	local targetfile="$(basename "$2")"
	
	if [[ "$1" =~ version.sh$ ]]; then
		bbuild_version_init "$targetfile"
		bbuild_version_adddetails "$targetfile"
	fi

	if ! (grep '#%bbflags' "$1"|grep 'nosc' -q); then
		do_shellcheck "$1"
	fi

}

function write_versioning_to {
	local targetfile="$1"; shift
	local vline="$(egrep -n '^#%VERSIONFILE' "$targetfile"|head -n 1|cut -d':' -f1)"

	if [[ "$vline" =~ ^[0-9]+$ ]]; then
		insert_file "$vline" "$targetfile" "$bbuild_versionfile"
	fi
}

function do_shellcheck {
	if [[ "$SHELLCHECK" = true ]]; then
		if ! getbin shellcheck >/dev/null ; then
			warne "You need to install shellcheck to perform syntax check"
			SHELLCHECK=false
		else
			shellcheck "$1"
		fi
	fi
}

function arg_valueof {
	echo "${1#*=}"
}

function parse_flag {
	case "$1" in
	-C|--no-check)
		SHELLCHECK=false
		;;
	-c|--check)
		SHELLCHECK=true
		;;
	--out=*)
		BUILDOUTD="$(arg_valueof "$1")"
		;;
	--ignore-tags)
		IGNORETAGS=unsafe
		;;
	--release)
		DOSETRELEASE=true
		;;
	--debug|--help)
		:
		;;
	*)
		faile "Unknown argument $1"
		;;
	esac
}

function build_files_list {
	for arg in "$@"; do
		if [[ -f "$arg" ]]; then
			debuge "File ${#prompt_file_list[@]} for processing: $arg"
			prompt_file_list[${#prompt_file_list[@]}]="$arg"

		elif [[ "$arg" =~ ^- ]]; then
			parse_flag "$arg"

		else
			faile "No such file $arg"
		fi
	done
}

function main {
	BBUILD_ENV_FILE=./bbuild_env

	# --- Defaults
	: ${BBPATH=./}
	: ${BUILDOUTD=./build-outd}
	: ${SHELLCHECK=false}

	# --- Settings file
	load_project_environment

	# --- Command line
	build_files_list "$@"

	# ++++++++++++++++
	# Now we process.

	setup_build_dir

	# BBFILES can be specified externally
	# command line overrides this IFF specified
	if [[ "${#prompt_file_list[@]}" -gt 0 ]]; then
		debuge "Prompt files list is ${prompt_file_list[*]}"
		BBFILES=("${prompt_file_list[@]}")
	fi
	
	debuge "And so, processing ${BBFILES[*]}"

	for infile in "${BBFILES[@]}"; do
		build_script "$infile"
	done
}

notest main "$@"
