#!/bin/bash

VERSION_NUM=5.0.0
VERSION_NOTE="See https://github.com/taikedz/bbuild"

[[ "$*" = --version ]] && {
	echo "$VERSION_NUM"
	echo "$VERSION_NOTE"
	exit
}

### Bash Builder 5 Usage:help
# 
# This project is hosted at
#   https://github.com/taikedz/bbuild
#
#
# Build a script using Bash Builder
#
# 	bbuild [OPTIONS ...] SCRIPTS ...
#
# Options
# -------
#
#   -c
#   --check
#   	use shellcheck for subsequent files
#
#   -C
#   --no-check
#   	don't use shellcheck for subsequent files
#
#   --ignore-tags
#   	Ignore tags in sourced files
#
#   --out=DIRECTORY
#   	Specify the output directory
#
# Environment
# -----------
#
# You can set environment variables in your .bashrc file, or in a local `./bbuild_env` file, which is sourced once before commencing build.
#
# The order of precedence for options and environment variables is:
#
# * command line arguments
# * `bbuild_env` settings
# * local environment settings
# * `.bashrc` settings
#
# Environment variables available, and their defaults:
#
# BBPATH -- a colon-separated list of directories wherein to find files for inclusion:
#
# 	BBPATH=$HOME/.local/lib/bbuild:/usr/local/lib/bbuild
#
#
# SHELLCHECK -- "true" or "false", whether to run shellcheck on the finally built script
#
# 	SHELLCHECK=false
#
#
# BUILDOUTD -- directory in which to place build results
#
#	BUILDOUTD=./build-outd
#
#
# IGNORETAGS -- if set to "unsafe", ignores tags and their effects.
#
# 	(unset by default)
#
# BBFILES -- a list of files to build ; overridden by any files specified on the command line
#   Surround these in parentheses to specify several scripts.
#   This allows simply running "bbuild" to build specified project scripts
#
# 	BBFILES=(src/script1 src/script2 libs/support_script)
#
###/doc

### runmain SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the runmain call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
	local required_name="$1"; shift
	local funcall="$1"; shift
	local scriptname="$(basename "$0")"

	if [[ "$required_name" = "$scriptname" ]]; then
		"$funcall" "$@"
	fi
}

#!/bin/bash

### autohelp:print Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from a running script, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
# 	autohelp:print
#
# You can set a different help section by specifying the 'SECTION_STRING' variable
#
# 	SECTION_STRING=subsection autohelp:print
#
###/doc

HELPCHAR='#'

function autohelp:print {
	local SECTION_STRING="${1:-}"; shift
	local TARGETFILE="${1:-}"; shift
	[[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
	[[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
				echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
	echo ""
}

### automatic help Usage:main
#
# automatically call help if "--help" is detected in arguments
#
###/doc
if [[ "$*" =~ --help ]]; then
	cols="$(tput cols)"
	autohelp:print | fold -w "$cols" -s || autohelp:print
	exit 0
fi
#!/bin/bash

### includefile.sh Usage:bbuild
#
# Utility to allow developer-defined inclusion directives in files being processed.
#
###/doc

#!/bin/bash

# FIXME - set function signature in head of help
### searchpaths:file_from PATHDEF FILE Usage:bbuild
#
# Locate a file along a search path.
#
# EXAMPLE
#
# The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
#	MYPATH="./lib:$HOME/.local/lib:/usr/local/lib"
# 	searchpaths:file_from "$MYPATH" file
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function searchpaths:file_from {
	local PATHS="$1"; shift
	local FILE="$1"; shift

	out:debug "Looking for file [$FILE] amongst [$PATHS]"

	for path in $(echo "$PATHS"|tr ':' ' '); do
		out:debug "Try path: $path"
		local fpath="$path/$FILE"
		if [[ -f "$fpath" ]]; then
			echo "$fpath"
			return
		else
			out:debug "No $fpath"
		fi
	done
	return 1
}
#!/bin/bash

### abspath Usage:bbuild
# Returns the absolute path of a file/directory
#
# Exposes two functions
#
#     abspath:path
#     abspath:simple
#
# Do not use the python-based 'abspath:path' for intensitve resolution;
# instead, use native 'abspath:simple' which is at least 170 times
# more efficient, at the cost of perhaps being potentially
# dumber (simply collapses '/./' and '/../').
# 
# Neither utility expands softlinks.
#
# If python is not found, abspath:path falls back to abspath:simple systematically.
###/doc

function abspath:path {
	local newvar=${1//"'"/"\\'"}
	(
		set +eu
		if which python >/dev/null 2>&1; then
			python  -c "import os ; print os.path.abspath('$newvar')"
		elif which python3 >/dev/null 2>&1 ; then
			python3 -c "import os ; print(os.path.abspath('$newvar') )"
		else
			abspath:simple "$newvar"
		fi
	)
}

# More efficient by a factor of at least 170:1
# compared to spinning up a python process every time
function abspath:simple {
	local workpath="$1"
	if [[ "${workpath:0:1}" != "/" ]]; then workpath="$PWD/$workpath"; fi
	for x in {1..50}; do # set a limit on how many iterations - only very stupid paths will get us here.
		if [[ "$workpath" =~ '/../' ]] || [[ "$workpath" =~ '/./' ]]; then
			workpath="$(echo "$workpath"|sed -r -e 's#/./#/#g' -e 's#([^/]+)/../#\1/#g' -e 's#/.$##' -e 's#([^/]+)/..$#\1#' )"
		else
			echo "$workpath"
			return 0
		fi
	done
	return 1 # hopefully we never get here
}

### includefile:include INFILE PATTERN [SEARCHPATHS] Usage:bbuild
#
# Inserts the contents of the files specified on lines matched by PATTERN into the stream of INFILE
# at the location they are declared.
#
# Inclusion directives must stand alone on their lines.
#
# Example:
#
# 	This is some content in the FILE called myfile.txt
#
# 	@@include external_file.txt external_2.txt
#
# 	We cannot include in the middle of a line. The following
# 	line will not be processed:
#
# 	( some line with @@inclusion file1 file2 )
#
# We can call this to include the contents of each file:
#
# 	includefile:include myfile.txt '@@include'
#
# The result will be something like
#
# 	This is some content in the FILE called myfile.txt
#
# 	(file1 contents)
#
# 	(file2 contents)
#
# 	We cannot include in the middle of a line. The following
# 	line will not be processed:
#
# 	( some line with @@inclusion file1 file2 )
#
# Note that files for inclusion MUST NOT have spaces in their names, or in their paths.
#
# SEARCH PATHS
# ============
#
# You can specify a colon (":") -separated list of directories wherein to search for files by calling
#
# 	includefile:include FILE PAT SEARCHPATHS
#
# This will search for the inclusions specified only along the specified paths. Example:
#
# 	includefile:include myfile.html '//!addstyle' "./importedstyles:$HOME/.local/lib/styles:/etc/htmlthing/styles"
# 
# This will seek to include the files named in the inclusion line of myfile.html first from a local ./importedstyles,
#  then from a general home configuration, and finally if it has found the file in neither the previous, it will be
#  searched for in the global configuration.
#
# If not specified, the default search path is simply the containing directory of myfile.html.
#
###/doc

function includefile:include {
	local INFILE="$1"; shift
	local PATTERN="$1"; shift
	local PATHS="$*"

	 while read inline; do
		out:debug "[36;1mInclusion target: $inline[0m"
	 	local pos="${inline%%:*}"
		inline="${inline#*:}"

		local inclusiontargets="${inline#$PATTERN }"

		# reverse inclusion targets
		# to insert always at same line, but preserve order of declaration
		local revintar=
		for targetfile in $inclusiontargets ; do
			revintar="$targetfile $revintar"
		done

		for targetfile in $revintar; do
			if [[ -z "$targetfile" ]]; then continue; fi
			local filepath="$(searchpaths:file_from "$PATHS" "$targetfile")"
			if [[ ! -f "$filepath" ]]; then
				out:warn "Could not find $targetfile in any of $PATHS"
				return 1
			fi
			includefile:fileinsert "$filepath" "$pos" "$INFILE"
		done

		sed "$pos d" -i "$INFILE"
	 done < <(grep -P "^$PATTERN" "$INFILE" -n | sort -r -n)
}

### includefile:fileinsert SOURCEFILE POSITION TARGETFILE Usage:bbuild
#
# Insert the contents of SOURCEFILE into TARGETFILE after line at POSITION
#
###/doc
function includefile:fileinsert {
	local SOURCEFILE="$(abspath:simple $1)"; shift
	local POSITION="$1"; shift
	local TARGETFILE="$1"; shift

	local SKIPFILE="$(includefile:getskipfile "$TARGETFILE")"

	if includefile:registerfile "$SKIPFILE" "$SOURCEFILE"; then
		out:debug "Inserting $SOURCEFILE at $TARGETFILE:$POSITION"

		includefile:docallback "$SOURCEFILE" "$TARGETFILE"

		sed "$POSITION r $SOURCEFILE" -i "$TARGETFILE"
	fi
}

function includefile:docallback {
	if [[ -n "$FILEINCLUDES_CALLBACK" ]]; then
		"$FILEINCLUDES_CALLBACK" "$@"
	fi
}

# Initialize the temp file
function includefile:inittemp {
	echo > "$(includefile:getskipfile "$1")"
}

# Get skipfile for path
# getskipfile TARGETPATH
# prints a temp file path in /tmp
function includefile:getskipfile {
	local tmpdir=/tmp/bbinclude
	mkdir -p "$tmpdir"
	
	local hash="$(echo "$1"|sha1sum)"
	hash="${hash:0:6}"

	local skipfile="$tmpdir/$hash"
	touch "$skipfile"
	echo "$skipfile"
}

# Internal method
# Register that a file has previously been included
# Returns 1 if already registered
function includefile:registerfile {
	local SKIPFILE="$1"; shift
	local TARGETFILE="$1"; shift

	if includefile:isregistered "$SKIPFILE" "$TARGETFILE"; then
		return 1
	fi

	echo "$TARGETFILE" >> "$SKIPFILE"
}

# Internal method
# check if file has already been reigstered
# returns 0 if yes
# returns 1 otherwise
function includefile:isregistered {
	local SKIPFILE="$1"; shift
	local TARGETFILE="$1"; shift

	if grep -P -q "^$TARGETFILE$" "$SKIPFILE"; then
		return 0
	fi

	return 1
}
#!/bin/bash

#!/bin/bash

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour"
#
# Colours available:
#
# CDEF -- switches to the terminal default
#
# CRED, CBRED -- red, bold red
# CGRN, CBGRN -- green, bold green
# CYEL, CBYEL -- yellow, bold yellow
# CBLU, CBBLU -- blue, bold blue
# CPUR, CBPUR -- purple, bold purple
#
###/doc

export CRED="\033[0;31m"
export CGRN="\033[0;32m"
export CYEL="\033[0;33m"
export CBLU="\033[0;34m"
export CPUR="\033[0;35m"
export CBRED="\033[1;31m"
export CBGRN="\033[1;32m"
export CBYEL="\033[1;33m"
export CBBLU="\033[1;34m"
export CBPUR="\033[1;35m"
export CDEF="\033[0m"

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'yes' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'yes' to enable command echoing
#
###/doc

: ${MODE_DEBUG=no}
: ${MODE_DEBUG_VERBOSE=no}

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "yes"
###/doc
function out:debug {
	if [[ "$MODE_DEBUG" = yes ]]; then
		echo -e "${CBBLU}DEBUG:$CBLU$*$CDEF" 1>&2
	fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
	echo -e "${CBYEL}WARN:$CYEL $*$CDEF" 1>&2
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift
	fi

	echo -e "${CBRED}ERROR FAIL:$CRED$*$CDEF" 1>&2
	exit $ERCODE
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
	echo -e -n "${CBPUR}$*" 1>&2
	echo -e -n "$CPUR" 1>&2
	cat - 1>&2
	echo -e -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires debug mode set to yes
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
# Press return to continue execution.
#
###/doc

function out:break {
	[[ "$MODE_DEBUG" = yes ]] || return

	read -p "${CRED}BREAKPOINT: $* >$CDEF " >&2
	if [[ "$REPLY" =~ quit|exit|stop ]]; then
		out:fail "ABORT"
	fi
}

[[ "$MODE_DEBUG_VERBOSE" = yes ]] && set -x || :
#!/bin/bash

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
	local BINEXE=
	for binname in "$@"; do
		# Some implementations of `which` print error messages
		# Not useful here.
		BINEXE=$(which "$binname" 2>/dev/null)

		if [[ -n "$BINEXE" ]]; then
			echo "$BINEXE"
			return 0
		fi
	done
	return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
	[[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
	local binname="$1"; shift

	[[ "$binname" =~ / ]] && { 
		# A relative path cannot be resolved, just check existence
		[[ -e "$binname" ]] && echo "$binname" || return 1

	} || binname="$(which "$binname" 2>/dev/null)"

	# `which` failed
	[[ -n "$binname" ]] || return 1

	[[ -h "$binname" ]] && {

		local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
		bincheck:path "$pointedname" ; return "$?"
	
	} || echo "$binname"
}

### Insert file contents Usage:bbuild
# 
# insertfile LINE DESTFILE SOURCEFILE
#
# Inserts the contents of SOURCEFILE into DESTFILE after line LINENUM
#
# When LINENUM is 0, inserts the contents before any of the lines of the file.
#
# Contrary to includefile, insertfil will always insert the file, even if it
# has done so previously.
#
###/doc

function insertfile {
	local line="$1"
	local destfile="$2"
	local sourcefile="$3"

	insertfile:checkargs "$@" || return 1

	local lcount="$(egrep ^ -c "$destfile")"

	if [[ "$1" -le 0 ]]; then
		insertfile:sedinsert "$destfile" "$sourcefile"

	elif [[ "$1" -gt $lcount ]]; then
		out:debug "Insertion point $1 > $lcount"
		breake "cat $sourcefile >> $destfile"
		cat "$sourcefile" >> "$destfile"

	else
		insertfile:sedappend "$@"
	fi

	breake "File insertion over."
}

function insertfile:sedappend {
	local line="$1"
	local destfile="$2"
	local sourcefile="$3"

	breake sed "$line r $sourcefile" -i "$destfile"
	sed "$line r $sourcefile" -i "$destfile"
}

function insertfile:sedinsert {
	local destfile="$1"
	local sourcefile="$2"

	breake sed "1 {
		h
		r $sourcefile
		g
		N
	}" -i "$destfile"
	sed "1 {
		h
		r $sourcefile
		g
		N
	}" -i "$destfile"
}

function insertfile:checkargs {
	if [[ ! "$1" =~ ^[0-9]+$ ]]; then echo "Invalid line number"; return 1 ; fi
	if [[ ! -f "$2" ]]; then echo "Not a file $2" >&2; return 1; fi
	if [[ ! -f "$3" ]]; then echo "Not a file $3" >&2; return 1; fi
}

function setup_build_dir {
	mkdir -p "$BUILDOUTD"
}

function load_project_environment {
	if [[ -f  "$BBUILD_ENV_FILE" ]]; then
		. "$BBUILD_ENV_FILE"
	fi
}

# checktags { FILENAME | TAG SPEC }
function checktags {
	if [[ -z "${1:-}" ]]; then return; fi

	if [[ "${IGNORETAGS:-}" = unsafe ]]; then
		return
	fi

	local tagsname="#%bbtags"
	if [[ "$1" != "$tagsname" ]]; then
		checktags $(grep "^$tagsname" "$1")
		return
	fi

	shift; # first arg is the bbtag
	
	for tag in "$@"; do
		case "$tag" in
			i:*)
				out:info "TAGS: $tag"
				;;
			w:*)
				out:warn "TAGS: $tag"
				;;
			e:*)
				out:fail "TAGS: $tag"
				;;
			*)	
				out:debug "TAGS: $tag"
				;;
		esac
	done
}

function build_script {
	local infile="$1"; shift
	local t_BBPATH="$(dirname "$infile"):$BBPATH"

	local fname="$(basename "$infile")"
	local tfile="$BUILDOUTD/$fname"
	cp "$infile" "$tfile"

	out:info "Building $infile to $tfile"

	local intoken="#%include"

	includefile:inittemp "$tfile"

	while grep -P "^$intoken" -q "$tfile" ; do
		includefile:include "$tfile" "$intoken" "$t_BBPATH" || out:fail "Inclusion on $tfile failed."
	done

	checktags "$tfile"

	chmod 755 "$tfile"
}

# Register callback function on-inclusion
FILEINCLUDES_CALLBACK=file_inclusion_callback
function file_inclusion_callback {
	out:debug "calling back on [$1] into [$2]"
	local targetfile="$(basename "$2")"

	if ! (grep '#%bbflags' "$1"|grep 'nosc' -q); then
		do_shellcheck "$1"
	fi

}

function do_shellcheck {
	if [[ "$SHELLCHECK" = true ]]; then
		if bincheck:has shellcheck ; then
			shellcheck -s bash "$1"
		else
			out:warn "You need to install shellcheck to perform syntax check"
			SHELLCHECK=false
		fi
	fi
}

function arg_valueof {
	echo "${1#*=}"
}

function parse_flag {
	case "$1" in
	-C|--no-check)
		SHELLCHECK=false
		;;
	-c|--check)
		SHELLCHECK=true
		;;
	--out=*)
		BUILDOUTD="$(arg_valueof "$1")"
		;;
	--ignore-tags)
		IGNORETAGS=unsafe
		;;
	--release)
		DOSETRELEASE=true
		;;
	*)
		out:fail "Unknown argument $1"
		;;
	esac
}

function build_files_list {
	for arg in "$@"; do
		if [[ -f "$arg" ]]; then
			out:debug "File ${#prompt_file_list[@]} for processing: $arg"
			prompt_file_list[${#prompt_file_list[@]}]="$arg"

		elif [[ "$arg" =~ ^- ]]; then
			parse_flag "$arg"

		else
			out:fail "No such file $arg"
		fi
	done
}

function main {
	BBUILD_ENV_FILE=./bbuild_env

	# --- Defaults
	: ${BBPATH=./}
	: ${BUILDOUTD=./build-outd}
	: ${SHELLCHECK=false}

	# --- Settings file
	load_project_environment

	# --- Command line
	build_files_list "$@"

	# ++++++++++++++++
	# Now we process.

	setup_build_dir

	# BBFILES can be specified externally
	# command line overrides this IFF specified
	if [[ "${#prompt_file_list[@]}" -gt 0 ]]; then
		out:debug "Prompt files list is ${prompt_file_list[*]}"
		BBFILES=("${prompt_file_list[@]}")
	fi
	
	out:debug "And so, processing ${BBFILES[*]}"

	for infile in "${BBFILES[@]}"; do
		build_script "$infile"
	done
}

runmain bbuild main "$@"
